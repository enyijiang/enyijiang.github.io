---
title: 'MPC Basics'
date: 2022-10-03
permalink: /posts/2022/10/mpc/
tags:
  - Multi-Party Computation
  - Security
  - Study
---
<script
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
  type="text/javascript">
</script>

# Some Basics

## Real-Ideal Paradigm

- **Ideal World**. The parties securely compute the function $\mathcal{F}$ by privately sending their inputs to a completely **trusted** party $\mathcal{T}$, who who simply computes $\mathcal{F}(x_1, x_2, ....x_n)$ and returns the result to all parties (**Functionality**).

- **Real World**. There is **no trusted party**. All parties communicate with each other using a protocol $\pi$, specifying for each party a "next message" function $\pi_{i}$.

Input: security parameter $\kappa$, the party’s private input $x_i$, a random tape, and the list of messages received so far.

Output: next message to send with destination or terminate the party with some output.

## Semi-Honest Adversary

A **semi-honest adversary** is one who corrupts parties but **follows** the protocol as specified. *honest-but-curious*: may try to learn as much as possible from the messages they receive.

## View of a Party & the Adversary
- **Real World**:
The *view* of a party consists of its private input, its random tape, and the list of all messages received during the protocol. The *view of an adversary*
consists of the **combined views** of **all** corrupt parties.

- Distribution of Real-world random variable:

$Real_{\pi} (\kappa, C; x_1, ..., x_n)$: run the protocol $\pi$ with security parameter $\kappa$, where each party $P_i$ runs the protocol honestly using private input $x_i$. Let $V_i$ denote the final view of party $P_i$, and let $y_i$ denote the final output of party $P_i$.
$\text{Output } \{ V_i \lvert i \in C \}, (y_1, ..., y_n)$.

- **Ideal World**: 
The *view of an adversary* in ideal world consists inputs sent to $\mathcal{T}$ and outputs received from $\mathcal{T}$. An ideal-world adversary must use this information to **generate** what looks like in the real-world, referred as **Simulator**.

- Distribution of Ideal-world random variable:

$Ideal_{\mathcal{F}, Sim} (\kappa, C; x_1, ..., x_n)$: Compute $(y_1, ..., y_n) \leftarrow \mathcal{F}(x_1, ..., x_n)$.
$\text{Output } Sim(C, \{ (x_i, y_i) \lvert i \in C \}), (y_1, ..., y_n)$.

## Semi-Honest Security
A protocol is secure against *semi-honest adversaries* if the corrupted parties in the real world have views that are **indistinguishable** from their views in the ideal world. (Distributions of the above two random variables are indistinguishable from each other).

- **Indistinguishable**: negligible probability.

## Malicious Adversary

- A malicious adversary can control, manipulate, and arbitrarily inject messages on the network.
- **Effect on honest outputs**: (note) we can/should make no guarantees on the final outputs of corrupt parties, only of the honest parties, since a
malicious party can output whatever it likes.
- **Extraction**: Honest parties have a well-defined inputs following the protocol while the input of a malicious party is not well-defined. Hence, we
leave it to the *simulator to choose inputs for the corrupt parties*.

## Distributions for the Real World and Ideal World
We use $\mathcal{A}$ denotes the adversary program in the real-world, we write $corrupt(\mathcal{A})$ to denote the set of parties that are corrupted, and use $corrupt(Sim)$ for the set of parties that are corrupted by the *ideal* adversary $Sim$. 

- $Real_{\pi, \mathcal{A}} (\kappa ; \{ x_i \lvert i \notin corrupt(\mathcal{A}) \})$: run the protocol on security parameter, where each honest party runs the protocol honestly using given private input $x_i$, and the messages of corrupt parties are chosen according to $\mathcal{A}$ (thinking of $\mathcal{A}$ as a protocol next-message function for a collection of parties).
$\text{Output } (\{ V_i \lvert i \in corrupt(\mathcal{A}) \}, \{y_i \lvert i \notin corrupt(\mathcal{A})\})$.

- $Ideal_{\mathcal{F}, Sim} (\kappa ; \{ x_i \lvert i \notin corrupt(\mathcal{A}) \})$: run $Sim$ until it outputs a set of inputs $\{ x_i \lvert i \notin corrupt(\mathcal{A}) \}$. Compute $(y_1, ..., y_n) \leftarrow \mathcal{F}(x_1, ..., x_n)$. Then, give $\{y_i \lvert i \notin corrupt(\mathcal{A})\}$ to $Sim$. Let $V^{\ast}$ denote the final output of $Sim$ (a set of simulated views).
$\text{Output } (V^{\ast}, \{y_i \lvert i \notin corrupt(\mathcal{A})\})$.
